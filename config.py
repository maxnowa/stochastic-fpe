import argparse
import sys
import os
import re
import numpy as np

# --- 1. Default Defaults ---
# These are used only if params.h doesn't exist yet
DEFAULT_PARAMS = {
    "PARAM_N_NEURONS": 500,
    "PARAM_T_MAX":     2000.0,
    "PARAM_TAU":       1,
    "PARAM_MU":        1.2,
    "PARAM_D":         0.01,
    "PARAM_V_TH":      1.0,
    "PARAM_V_RESET":   0.0,
    "PARAM_DT_NET":    0.005,
    "PARAM_GRID_N":    500,
    "PARAM_METHOD":    1, 
    "PARAM_FLUX_METHOD": 1,
    "PARAM_DELAY": 0,
    "PARAM_W": -1,
    "PARAM_RECURRENCE": 1
}

PARAMS_HEADER_PATH = "src/params.h"

# --- 2. Helper Functions ---

def load_params_from_header():
    """
    Reads the existing C header file to determine the CURRENT configuration.
    This ensures python scripts see exactly what the C code was compiled with.
    """
    params = DEFAULT_PARAMS.copy()
    
    if not os.path.exists(PARAMS_HEADER_PATH):
        return params

    try:
        with open(PARAMS_HEADER_PATH, 'r') as f:
            content = f.read()
            
        # Regex to find #define KEY VALUE
        # Captures keys and values (integers or floats)
        matches = re.findall(r'#define\s+(PARAM_\w+)\s+([-\d\.]+)', content)
        
        for key, val_str in matches:
            if key in params:
                # Convert to correct type based on default
                target_type = type(DEFAULT_PARAMS[key])
                params[key] = target_type(val_str)
                
    except Exception as e:
        print(f"Warning: Could not parse {PARAMS_HEADER_PATH}: {e}")
        
    return params

def calculate_derived(p):
    """Calculates derived physics parameters (CV, R0)."""
    # Use dummy logic if analysis lib is missing
    try:
        from analysis.lif import cv_benji, rate_whitenoise_benji
        p["PARAM_CV"] = cv_benji(p["PARAM_MU"], p["PARAM_D"])
        p["PARAM_R0"] = rate_whitenoise_benji(p["PARAM_MU"], np.sqrt(p["PARAM_D"]))
    except ImportError:
        p["PARAM_CV"] = 0.0
        p["PARAM_R0"] = 0.0
    return p

# --- 3. The "Hybrid" Logic ---

if __name__ == "__main__":
    # === CLI MODE (Called by Makefile) ===
    # We parse args and WRITE the header
    
    parser = argparse.ArgumentParser(description="Generate params.h")
    for key, val in DEFAULT_PARAMS.items():
        parser.add_argument(f"--{key}", type=type(val), default=val)
        
    args = parser.parse_args()
    new_params = vars(args)
    new_params = calculate_derived(new_params)

    # Write Header
    header = "#ifndef PARAMS_H\n#define PARAMS_H\n\n"
    header += "// Auto-generated by config.py. Single Source of Truth.\n"
    header += f"// CLI Args: {' '.join(sys.argv[1:])}\n\n"
    
    for key, val in new_params.items():
        if isinstance(val, int):
             header += f"#define {key} {val}\n"
        else:
             header += f"#define {key} {val:.8f}\n"
    header += "\n#endif\n"
    
    # Ensure src directory exists
    os.makedirs(os.path.dirname(PARAMS_HEADER_PATH), exist_ok=True)
    
    with open(PARAMS_HEADER_PATH, "w") as f:
        f.write(header)
    print(f"âœ“ Updated {PARAMS_HEADER_PATH}")

else:
    # === IMPORT MODE (Called by plot scripts) ===
    # We READ the header to get the live config
    PARAMS = load_params_from_header()
    # Recalculate derived stats (since they aren't always #defined in C)
    PARAMS = calculate_derived(PARAMS)